# **HashMap**

## 简述
本篇幅主记录Java8中的HashMap.
HashMap允许key-value为NULL;
线程不安全;

希望线程安全Map, 推荐以下方式:  
1. Collections.synchronizedMap(...);
2. ConcurrentHashMap();
3. ConcurrentSkipListMap();   --- 有序Map,基于跳表结构;



## 数据结构
结构顺序: **自然无序,也不保证时间线顺序**  
有序Map: **LinkedHashMap**

结构一: **数组+链表**       -> 时间复杂度: <Latex>O(n)</Latex>    
结构二: **数组+链表+红黑树** -> 时间复杂度: <Latex>O(log_n)</Latex>  

HashMap链表插入节点的方式, 在Java1.7中, 插入链表节点使用**头插法**;Java1.8中变成了**尾插法**;  

节点的实体是嵌套类 Node 的实例, Node 包含四个属性:key, value, hash 值和用于单向链表的 next  

1. capacity:当前数组容量, 始终保持 2^n, 可以扩容, 扩容后数组大小为当前的 2 倍  
2. loadFactor:负载因子, 默认为 0.75  
3. threshold:扩容的阈值, 等于 capacity * loadFactor 



## 原理以及面试题

### 简述HashMap中put方法的过程

调用哈希函数获取Key对应的hash值, 再计算其数组下标；

如果没有出现哈希冲突, 则直接放入数组；如果出现哈希冲突, 则以链表的方式放在链表后面；

如果链表长度超过阀值8, 就把链表转成红黑树, 链表长度低于6, 就把红黑树转回链表;

如果结点的key已经存在, 则替换其value即可；

如果集合中的键值对大于12, 调用resize方法进行数组扩容;



### 为什么长度是2的幂次?

1. 让高位参与计算, 减少hash碰撞

2. 不需要像1.7扩容一样, 所有元素都需要rehash; 下次扩容时, 通过高位运算**（e.hash & oldCap）**来确定元素是否需要移动

   新的下标位置 = 原下标位置 + 原数组长度



### HashMap怎么解决哈希冲突的?

1. 使用链地址法, 来链接拥有相同hash值的数据

2. 使用2次扰动函数(hash函数)来降低哈希冲突的概率, 使得数据分布更平均



### hashmap为什么不做取余运算?

首先 a%b 等价 a&(b-1)

此公式前置要求是 b=**2n**

因为可以保证b始终只有最高位为1, 其他二进制位全部为0, 减去1, 之后, 可以把高位1消除, 其他位都为1, 而与1做&运算, 会保留原来的数













